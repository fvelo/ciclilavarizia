using Microsoft.Extensions.DependencyInjection;
using System.Security.Cryptography;
using System.Text;

namespace CommonCiclilavarizia
{
    public static class EncryptionServiceExtension
    {
        public static IServiceCollection AddCustomEncryptionService(this IServiceCollection services)
        {
            services.AddScoped<Encryption>();
            return services;
        }
    }

    public class EncryptionHandler
    {
        public string Sha256Encrypt(string input)
        {
            using (var sha256 = SHA256.Create())
            {
                byte[] bytes = Encoding.UTF8.GetBytes(input);
                byte[] hash = sha256.ComputeHash(bytes);
                return Convert.ToBase64String(hash);
            }
        }

        public string Sha512Encrypt(string input)
        {
            using (var sha512 = SHA512.Create())
            {
                byte[] bytes = Encoding.UTF8.GetBytes(input);
                byte[] hash = sha512.ComputeHash(bytes);
                return Convert.ToBase64String(hash);
            }
        }
    }
    /// <summary>
    /// Encryption utilities for hashing with SHA-256 using per-password salt + application pepper.
    /// </summary>
    public class Encryption
    {
        private readonly byte[] _pepperBytes;
        private const int DefaultSaltSize = 6; // bytes
        private const int DefaultIterations = 100_000; // tune to taste & CPU (higher == slower) because more cicli

        /// <summary>
        /// Create an Encryption instance with a pepper.
        /// </summary>
        /// <param name="pepper">Secret application pepper (string). Not stored in the DB.</param>
        public Encryption(string pepper = "Test") // The pepper MUST be kept secret(environment variable, secret manager, or HSM).
        {
            if (string.IsNullOrEmpty(pepper))
                throw new ArgumentException("Pepper must be provided and non-empty.", nameof(pepper));

            _pepperBytes = Encoding.UTF8.GetBytes(pepper);
        }

        /// <summary>
        /// Generate a cryptographically secure random salt (Base64-encoded).
        /// Store this salt with the user's record.
        /// </summary>
        public string GenerateSalt(int size = DefaultSaltSize)
        {
            if (size <= 0) throw new ArgumentOutOfRangeException(nameof(size));
            var salt = new byte[size];
            RandomNumberGenerator.Fill(salt);
            return Convert.ToBase64String(salt);
        }

        /// <summary>
        /// Hash a password using SHA-256 with salt and pepper and multiple iterations.
        /// Returns the hash as Base64. You should store the returned hash together with the salt and the iterations used.
        /// </summary>
        /// <param name="password">The plaintext password</param>
        /// <param name="saltBase64">Base64 salt (generated by GenerateSalt)</param>
        /// <param name="iterations">Number of iterations (increase to slow down hashing)</param>
        public string HashPassword(string password, string saltBase64, int iterations = DefaultIterations)
        {
            if (password is null) throw new ArgumentNullException(nameof(password));
            if (saltBase64 is null) throw new ArgumentNullException(nameof(saltBase64));
            if (iterations <= 0) throw new ArgumentOutOfRangeException(nameof(iterations));

            byte[] salt = Convert.FromBase64String(saltBase64);
            // Use HMAC-SHA256 with pepper as key. We apply iterations to increase cost.
            using (var hmac = new HMACSHA256(_pepperBytes))
            {
                // initial input = password bytes concatenated with salt (pepper is in key)
                byte[] input = Concat(Encoding.UTF8.GetBytes(password), salt);
                byte[] hash = hmac.ComputeHash(input);

                // iterate: hash = HMAC(pepper, previousHash) repeated (iterations-1) times
                for (int i = 1; i < iterations; i++)
                {
                    hash = hmac.ComputeHash(hash);
                }

                return Convert.ToBase64String(hash);
            }
        }

        /// <summary>
        /// Verify a password against a stored hash and salt.
        /// Uses constant-time comparison to avoid timing attacks.
        /// </summary>
        public bool VerifyPassword(string password, string saltBase64, string expectedHashBase64, int iterations = DefaultIterations)
        {
            if (password is null) throw new ArgumentNullException(nameof(password));
            if (saltBase64 is null) throw new ArgumentNullException(nameof(saltBase64));
            if (expectedHashBase64 is null) throw new ArgumentNullException(nameof(expectedHashBase64));

            string candidate = HashPassword(password, saltBase64, iterations);
            byte[] expected = Convert.FromBase64String(expectedHashBase64);
            byte[] candidateBytes = Convert.FromBase64String(candidate);

            // Use built-in constant-time comparison if available:
#if NETCOREAPP || NET5_0_OR_GREATER
            return CryptographicOperations.FixedTimeEquals(expected, candidateBytes);
#else
            return FixedTimeEquals(expected, candidateBytes);
#endif
        }

        /// <summary>
        /// Original Sha256 bare function (kept for compatibility) - DOES NOT use salt/pepper.
        /// Prefer HashPassword for real password hashing.
        /// </summary>
        public string Sha256Encrypt(string input)
        {
            using (var sha256 = SHA256.Create())
            {
                byte[] bytes = Encoding.UTF8.GetBytes(input);
                byte[] hash = sha256.ComputeHash(bytes);
                return Convert.ToBase64String(hash);
            }
        }

        /// <summary>
        /// Original Sha512 bare function (kept for compatibility)
        /// </summary>
        public string Sha512Encrypt(string input)
        {
            using (var sha512 = SHA512.Create())
            {
                byte[] bytes = Encoding.UTF8.GetBytes(input);
                byte[] hash = sha512.ComputeHash(bytes);
                return Convert.ToBase64String(hash);
            }
        }

        // Helper: concat two byte arrays
        private byte[] Concat(byte[] a, byte[] b)
        {
            var outb = new byte[a.Length + b.Length];
            Buffer.BlockCopy(a, 0, outb, 0, a.Length);
            Buffer.BlockCopy(b, 0, outb, a.Length, b.Length);
            return outb;
        }
    }
}
